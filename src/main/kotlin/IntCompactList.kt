package dev.whyoleg.testtask

import org.objectweb.asm.*
import org.objectweb.asm.Opcodes.*
import org.objectweb.asm.Type
import java.lang.reflect.*

@PublishedApi
internal fun newIntCompactList(initialSize: Int): CompactList<Int> = IntCompactListClassLoader.create(initialSize)

/**
 * Custom [ClassLoader] to be able to load class from generated bytecode.
 */
private object IntCompactListClassLoader : ClassLoader(CompactList::class.java.classLoader) {
    private const val CLASS_NAME = "dev.whyoleg.testtask.IntCompactList"
    private val constructor: Constructor<*>

    init {
        val bytes = generateIntCompactListClassLoader()
        val cls = defineClass(CLASS_NAME, bytes, 0, bytes.size)
        constructor = cls.getConstructor(Int::class.javaPrimitiveType)
    }

    fun create(initialSize: Int): CompactList<Int> {
        @Suppress("UNCHECKED_CAST")
        return constructor.newInstance(initialSize) as CompactList<Int>
    }

    private fun generateIntCompactListClassLoader(): ByteArray {
        val className = CLASS_NAME.replace(".", "/")
        val intDescriptor = "I"
        val intArrayDescriptor = "[I"
        val stringBuilderDescriptor = "java/lang/StringBuilder"

        val writer = ClassWriter(ClassWriter.COMPUTE_FRAMES).apply {
            // declare class header
            visit(
                    V1_8,
                    ACC_PUBLIC or ACC_FINAL or ACC_SUPER,
                    className,
                    "Ljava/lang/Object;Ldev/whyoleg/testtask/CompactList<Ljava/lang/Integer;>;",
                    "java/lang/Object",
                    arrayOf("dev/whyoleg/testtask/CompactList")
            )

            // declare private fields of class
            visitField(ACC_PRIVATE, "size", intDescriptor, null, null).visitEnd()
            visitField(ACC_PRIVATE, "values", intArrayDescriptor, null, null).visitEnd()

            // declare constructor(initialSize: Int)
            visitMethod(ACC_PUBLIC, "<init>", Type.getMethodDescriptor(Type.VOID_TYPE, Type.INT_TYPE), null, null).visiting {
                val varIndexOfInitialSize = 1 // index of `initialSize` constructor parameter
                // call Object constructor
                visitVarInsn(ALOAD, 0)
                visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", Type.getMethodDescriptor(Type.VOID_TYPE), false)
                // create new int[] of size=initialSize
                visitVarInsn(ALOAD, 0)
                visitVarInsn(ILOAD, varIndexOfInitialSize)
                visitIntInsn(NEWARRAY, T_INT)
                // save the created array into `values` field of class
                visitFieldInsn(PUTFIELD, className, "values", intArrayDescriptor)
                visitInsn(RETURN)
            }

            // declare getSize method - getter of `size` property
            visitMethod(ACC_PUBLIC, "getSize", Type.getMethodDescriptor(Type.INT_TYPE), null, null).visiting {
                visitVarInsn(ALOAD, 0)
                visitFieldInsn(GETFIELD, className, "size", intDescriptor)
                visitInsn(IRETURN)
            }

            // add(Int) method
            visitMethod(ACC_PUBLIC, "add", "(Ljava/lang/Object;)V", null, null).visiting {
                val varIndexOfValue = 1  // index of `value` parameter

                val varIndexOfValues = 2  // index of `values` local variable
                // store `values` field into local variable
                visitVarInsn(ALOAD, 0)
                visitFieldInsn(GETFIELD, className, "values", "[I")
                visitVarInsn(ASTORE, varIndexOfValues)

                val varIndexOfSize = 3 // index of `size` local variable
                // store `size` field into local variable
                visitVarInsn(ALOAD, 0)
                visitFieldInsn(GETFIELD, className, "size", "I")
                visitVarInsn(ISTORE, varIndexOfSize)

                val varIndexOfValuesSize = 4 // index of `values.size` local variable
                // store `values.size` field into local variable
                visitVarInsn(ALOAD, varIndexOfValues)
                visitInsn(ARRAYLENGTH)
                visitVarInsn(ISTORE, varIndexOfValuesSize)

                val noNeedToGrowLabel = Label()
                // if `size` < `values.size` -> no need to grow array -> jump to saving
                visitVarInsn(ILOAD, varIndexOfSize)
                visitVarInsn(ILOAD, varIndexOfValuesSize)
                visitJumpInsn(IF_ICMPLT, noNeedToGrowLabel)


                val varIndexOfNewSize = 5 // index of `newSize` local variable
                val valuesSizeIsNotZeroLabel = Label()
                val storeNewSizeLabel = Label()
                visitVarInsn(ILOAD, varIndexOfValuesSize)
                // if `values.size` != 0 -> jump
                visitJumpInsn(IFNE, valuesSizeIsNotZeroLabel)
                // if `values.size` == 0 -> use default value and then jump to `storeNewSizeLabel`
                visitIntInsn(BIPUSH, DEFAULT_SIZE)
                visitJumpInsn(GOTO, storeNewSizeLabel)
                visitLabel(valuesSizeIsNotZeroLabel)
                // multiply current size by 2
                visitVarInsn(ILOAD, varIndexOfValuesSize)
                visitInsn(ICONST_2)
                visitInsn(IMUL)
                // store computed value to `newSize`
                visitLabel(storeNewSizeLabel)
                visitVarInsn(ISTORE, varIndexOfNewSize)

                // check `newSize` variable overflow -> if overflowed, throw OOM
                val newSizeIsPositiveLabel = Label()
                visitVarInsn(ILOAD, varIndexOfNewSize)
                visitJumpInsn(IFGE, newSizeIsPositiveLabel) // if >= 0

                // create an exception object, initialize it with `message` and throw
                visitTypeInsn(NEW, "java/lang/OutOfMemoryError")
                visitInsn(DUP)
                visitLdcInsn("Required size exceeds implementation limit")
                visitMethodInsn(INVOKESPECIAL, "java/lang/OutOfMemoryError", "<init>", "(Ljava/lang/String;)V", false)
                visitInsn(ATHROW)

                visitLabel(newSizeIsPositiveLabel)

                // create a new array from `values` with new size
                visitVarInsn(ALOAD, 0)
                visitVarInsn(ALOAD, varIndexOfValues)
                visitVarInsn(ILOAD, varIndexOfNewSize)
                visitMethodInsn(INVOKESTATIC, "java/util/Arrays", "copyOf", "([II)[I", false)
                // save the new array to `values` field
                visitFieldInsn(PUTFIELD, className, "values", "[I")

                visitLabel(noNeedToGrowLabel)

                // equivalent of values[size] = ((Number) value).intValue()
                visitVarInsn(ALOAD, 0)
                visitFieldInsn(GETFIELD, className, "values", "[I")
                visitVarInsn(ILOAD, varIndexOfSize)
                visitVarInsn(ALOAD, varIndexOfValue)
                // cast Object to Number and then get primitive `int` value, as we have `int[]` underlying array
                visitTypeInsn(CHECKCAST, "java/lang/Number");
                visitMethodInsn(INVOKEVIRTUAL, "java/lang/Number", "intValue", "()I", false)
                visitInsn(IASTORE)

                // increment size
                visitVarInsn(ALOAD, 0)
                visitVarInsn(ILOAD, varIndexOfSize)
                visitInsn(ICONST_1)
                visitInsn(IADD)
                // save incremented size
                visitFieldInsn(PUTFIELD, className, "size", "I")
                visitInsn(RETURN)
            }

            // declare add(index: Int): Int method (in reality, it returns Object, because we have generics)
            visitMethod(ACC_PUBLIC, "get", Type.getMethodDescriptor(Type.getType(Any::class.java), Type.INT_TYPE), null, null).visiting {
                val varIndexOfIndex = 1  // index of `index` function parameter

                val varIndexOfSize = 2  // index of `size` local variable
                // store `size` field into local variable
                visitVarInsn(ALOAD, 0)
                visitFieldInsn(GETFIELD, className, "size", intDescriptor)
                visitVarInsn(ISTORE, varIndexOfSize)

                val needThrowLabel = Label()

                // check if `index` < 0 -> jump to `needThrowLabel`
                visitVarInsn(ILOAD, varIndexOfIndex)
                visitJumpInsn(IFLT, needThrowLabel)

                // check if `index` >= `size` -> jump to `needThrowLabel`
                visitVarInsn(ILOAD, varIndexOfIndex)
                visitVarInsn(ILOAD, varIndexOfSize)
                visitJumpInsn(IF_ICMPGE, needThrowLabel)

                //load value by `index` parameter from `values` field
                visitVarInsn(ALOAD, 0)
                visitFieldInsn(GETFIELD, className, "values", "[I")
                visitVarInsn(ILOAD, varIndexOfIndex)
                visitInsn(IALOAD)
                // convert primitive `int` to object `Integer` - because of generics
                visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false)
                // return from function
                visitInsn(ARETURN)

                // there was jump to `needThrowLabel` -> create and throw error
                visitLabel(needThrowLabel)

                // create exception
                visitTypeInsn(NEW, "java/lang/IndexOutOfBoundsException")
                visitInsn(DUP)
                // create StringBuilder to construct message
                visitTypeInsn(NEW, stringBuilderDescriptor)
                visitInsn(DUP)
                // call StringBuilder constructor
                visitMethodInsn(INVOKESPECIAL, stringBuilderDescriptor, "<init>", Type.getMethodDescriptor(Type.VOID_TYPE), false)
                // append first constant string
                visitLdcInsn("Index ")
                visitMethodInsn(INVOKEVIRTUAL, stringBuilderDescriptor, "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false)
                // append `index`
                visitVarInsn(ILOAD, varIndexOfIndex)
                visitMethodInsn(INVOKEVIRTUAL, stringBuilderDescriptor, "append", "(I)Ljava/lang/StringBuilder;", false)
                // append next constant string
                visitLdcInsn(" out of bounds for size ")
                visitMethodInsn(INVOKEVIRTUAL, stringBuilderDescriptor, "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false)
                // append `size`
                visitVarInsn(ILOAD, varIndexOfSize)
                visitMethodInsn(INVOKEVIRTUAL, stringBuilderDescriptor, "append", "(I)Ljava/lang/StringBuilder;", false)
                // build string, call exception constructor and throw it
                visitMethodInsn(INVOKEVIRTUAL, stringBuilderDescriptor, "toString", "()Ljava/lang/String;", false)
                visitMethodInsn(INVOKESPECIAL, "java/lang/IndexOutOfBoundsException", "<init>", "(Ljava/lang/String;)V", false)
                visitInsn(ATHROW)
            }
        }.also(ClassWriter::visitEnd)

        return writer.toByteArray()
    }

    private inline fun MethodVisitor.visiting(block: MethodVisitor.() -> Unit) {
        block()
        // maxs will be automatically computed because we create ClassWriter with ClassWriter.COMPUTE_MAXS flag
        visitMaxs(0, 0)
        visitEnd()
    }
}
